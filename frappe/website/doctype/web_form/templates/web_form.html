{% extends "templates/web.html" %}

{% block title %}{{ _(title) }}{% endblock %}

{% block header %}
<h2>{{ _(title) }}</h2>
{% endblock %}

{% block breadcrumbs %}
{% if has_header and login_required %}
{% include "templates/includes/breadcrumbs.html" %}
{% endif %}
{% endblock %}

{% block header_actions %}
{% if is_list %}
<div class="list-view-actions"></div>
{% else %}
<div class="web-form-actions"></div>
{% endif %}
{% endblock %}

{% macro container_attributes() %}
data-web-form="{{ name }}" data-web-form-doctype="{{ doc_type }}" data-login-required="{{ frappe.utils.cint(login_required and frappe.session.user=='Guest') }}" data-is-list="{{ frappe.utils.cint(is_list) }}" data-allow-delete="{{ allow_delete }}"
{% endmacro %}

{% block page_content %}
<div>
	{% if is_list %}
	{# web form list #}
	<div class="web-form-wrapper" {{ container_attributes() }}></div>
	<div id="list-filters" class="row"></div>
	<div id="datatable" class="pt-4 table-responsive table-fixed-con">
	</div>
	<div class="list-view-footer text-right"></div>
	{% else %}
	{# web form #}
	<div role="form">
		<div id="introduction" class="text-muted"></div>
		<hr>
		<div class="web-form-wrapper" {{ container_attributes() }}>
			{% if title == "Address" or allow_edit == 1 %}
			<div class="frappe-control">
				<div class="form-group">
					<div class="clearfix">
						<label class="control-label reqd" style="padding-right: 0px;">Search and Select Address</label>
					</div>
					<div class="control-input-wrapper">
						<div class="control-input" style="display: flex;">
							<input type="text" id="google-search-address" class="input-with-feedback form-control mr-2" placeholder="" autocomplete="off" required>
							<button id="search-btn" class="btn text-white">ADD</button>
						</div>
					</div>
					<p style="font-size: 15px;color: red;">Search and Select here for add Address.</p>
				</div>
			</div>
			{% endif %}
		</div>
		<div class="web-form-footer pull-right"></div>
	</div>

	{% if show_attachments and not frappe.form_dict.new and attachments %}
	<div class="attachments">
		<h5>{{ _("Attachments") }}</h5>
		{% for attachment in attachments %}
		<div class="attachment">
			<a class="no-underline attachment-link" href="{{ attachment.file_url }}" target="blank">
				<div class="row">
					<div class="col-9">
						<span class="file-name">{{ attachment.file_name }}</span>
					</div>
					<div class="col-3">
						<span class="pull-right file-size">{{ attachment.file_size }}</span>
					</div>
				</div>
			</a>
		</div>
		{% endfor %}
	</div>
	{% endif %} {# attachments #}

	{% if allow_comments and not frappe.form_dict.new and not is_list -%}
	<div class="comments mt-6">
		<h3>{{ _("Comments") }}</h3>
		{% include 'templates/includes/comments/comments.html' %}
	</div>
	{%- endif %} {# comments #}

	{% endif %}
</div>
{% endblock page_content %}

{% block script %}
<script>
frappe.boot = {
	sysdefaults: {
		float_precision: parseInt("{{ frappe.get_system_settings('float_precision') or 3 }}"),
		date_format: "{{ frappe.get_system_settings('date_format') or 'yyyy-mm-dd' }}",
	}
};
// for backward compatibility of some libs
frappe.sys_defaults = frappe.boot.sysdefaults;
frappe._messages = {{ translated_messages }};
$(".file-size").each(function() {
	$(this).text(frappe.form.formatters.FileSize($(this).text()));
});
</script>
<script type="text/javascript" src="/assets/js/control.min.js"></script>
{% if is_list %}
{# web form list #}
<script type="text/javascript" src="/assets/js/moment-bundle.min.js"></script>
<script type="text/javascript" src="/assets/js/dialog.min.js"></script>
<script type="text/javascript" src="/assets/js/web_form.min.js"></script>
<script type="text/javascript" src="/assets/js/bootstrap-4-web.min.js"></script>
{% else %}
{# web form #}
<script type="text/javascript" src="/assets/js/dialog.min.js"></script>
<script type="text/javascript" src="/assets/js/moment-bundle.min.js"></script>
<script type="text/javascript" src="/assets/frappe/node_modules/vue/dist/vue.js"></script>
<script>
	Vue.prototype.__ = window.__;
	Vue.prototype.frappe = window.frappe;
</script>
<script type="text/javascript" src="/assets/js/web_form.min.js"></script>
<script type="text/javascript" src="/assets/js/bootstrap-4-web.min.js"></script>
<script>

{% if client_script %}
frappe.init_client_script = () => {
	try {
		{{ client_script }}
	} catch(e) {
		console.error('Error in web form client script');
		console.error(e);
	}
}
{% endif %}

{% if script is defined %}
	{{ script }}
{% endif %}
</script>
{% endif %}
{% endblock script %}

{% block style %}
{% if not is_list %}
<link type="text/css" rel="stylesheet" href="/assets/css/web_form.css">
{% endif %}

<style>
{% if style is defined %}
	{{ style }}
{% endif %}
{% if custom_css %}
	{{ custom_css }}
{% endif %}
</style>

<!-- Include this script in your Frappe web form -->
<script>
    // Initialize Autocomplete when the window loads
    window.onload = initializeAutocomplete;

    const disallowedStates = ["Alabama", "Arkansas", "Indiana", "Vermont", "Wisconsin", "Rhode Island"];
    const disallowedCities = ["Sarasota County Florida", "San Diego", "Jerseyville", "Denver"];

    // Function to initialize Google Places Autocomplete
    function initializeAutocomplete() {
        const searchAddressInput = document.getElementById('google-search-address');
        const autocompleteService = new google.maps.places.AutocompleteService();
        const autocomplete = new google.maps.places.Autocomplete(searchAddressInput, {
            types: ['geocode'],
            componentRestrictions: { country: 'US' }
        });

        if (searchAddressInput) {

            // Add event listener for input changes
            searchAddressInput.addEventListener('input', function () {
                const inputText = this.value;

                // Define the autocomplete request
                const autocompleteRequest = {
                    input: inputText,
                    types: ['geocode'], // Specify the types of predictions you want (e.g., 'geocode' for addresses)
                    componentRestrictions: { country: 'US' } // Restrict predictions to a specific country
                };

                // Define the callback function to handle the predictions
                const autocompleteCallback = function (predictions, status) {
                    if (status === google.maps.places.PlacesServiceStatus.OK && predictions) {
                        // Handle the predictions (e.g., update a suggestion dropdown)
                        handleAutocompletePredictions(predictions);
                    } else {
                        // Handle errors or no predictions
                        console.error('Autocomplete request failed:', status);
                    }
                };
                
                // Make the autocomplete request
                autocompleteService.getPlacePredictions(autocompleteRequest, autocompleteCallback);
            });
            const place = autocomplete.getPlace();
            console.log(place)
        }

        // Add click event handler for the "Add" button
        const addButton = document.getElementById('search-btn');
        if (addButton) {
            addButton.addEventListener('click', function () {
                const inputText = searchAddressInput.value;

                // Define the autocomplete request
                const autocompleteRequest = {
                    input: inputText,
                    types: ['geocode'],
                    componentRestrictions: { country: 'US' }
                };

                // Make the autocomplete request
                autocompleteService.getPlacePredictions(autocompleteRequest, function (predictions, status) {
                    if (status === google.maps.places.PlacesServiceStatus.OK && predictions && predictions.length > 0) {
                        // Use the first prediction to fetch place details
                        const placeId = predictions[0].place_id;

                        // Use PlacesService to get details for the selected place
                        const placesService = new google.maps.places.PlacesService(document.createElement('div'));
                        placesService.getDetails({ placeId: placeId }, function (place, status) {
                            if (status === google.maps.places.PlacesServiceStatus.OK) {
                                // Process the selected place and populate form fields
                                const selectedState = place.address_components.find(component => component.types.includes('administrative_area_level_1')).long_name;
                                const selectedCity = place.address_components.find(component => component.types.includes('locality')).long_name;
								if (disallowedStates.includes(selectedState)) {
                                    frappe.msgprint('Enter City or State is not allowed. Please choose a different one.');
                                    return;
                                }
                                
                                if (disallowedCities.includes(selectedCity)) {
                                    frappe.msgprint('Enter City or State is not allowed. Please choose a different one.');
                                    return
                                }
                                processSelectedPlace(place);
                            } else {
                                console.error('Error fetching place details:', status);
                                // Handle error as needed
                            }
                        });
                    } else {
                        // No valid predictions, show an error
                        frappe.msgprint("No valid address found. Please enter a valid address.");
                    }
                });
            });
        }
    }

    // Function to handle predictions
    function handleAutocompletePredictions(predictions) {
        // Process and display the predictions as needed
        console.log('Autocomplete predictions:', predictions);
        // Example: update a suggestion dropdown or display predictions in the UI
    }

    // Function to process the selected place and populate form fields
    function processSelectedPlace(place) {

        // Default values for form fields
        let defaultStreet = '';
        let defaultCity = '';
        let defaultState = '';
        let defaultPostalcode = '';

        // Loop through the address components to extract street, city, and state
        place.address_components.forEach((component) => {
            const types = component.types;
            if (types.includes('route')) {
                defaultStreet = component.long_name;
            } else if (types.includes('locality')) {
                defaultCity = component.long_name;
            } else if (types.includes('administrative_area_level_1')) {
                defaultState = component.long_name;
            } else if (types.includes('postal_code')) {
                defaultPostalcode = component.long_name;
            }
        });

		frappe.web_form.set_value('address_line1', place.name);
        frappe.web_form.set_value('address_line2', defaultStreet);
        frappe.web_form.set_value('city', defaultCity);
        frappe.web_form.set_value('state', defaultState);
        frappe.web_form.set_value('pincode', defaultPostalcode);
    }

</script>

{% endblock %}
